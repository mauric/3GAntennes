
% This LaTeX was auto-generated from MATLAB code.
% To make changes, update the MATLAB code and republish this document.

\documentclass[10pt,a4paper]{report}%,twocolumn
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{caption}
\usepackage{subcaption}





\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}

\usepackage{listings}
	
\lstset{
	style=Matlab-editor,
	basicstyle         = \fontsize{9}{11}\ttfamily,
	numberstyle       =\fontsize{9}{11}\ttfamily,
	%backgroundcolor=\color{gray},
	mlshowsectionrules = true,
	rangeprefix        = \%\ 
}


\definecolor{lightgray}{gray}{0.5}
\setlength{\parindent}{0pt}
\usepackage[left=2.50cm, right=1.00cm, top=1.00cm, bottom=1.00cm]{geometry}
\author{Mauricio Caceres}
\title{Antennes Intelligentes}
\begin{document}

\maketitle
\tableofcontents
\part{Front-end Radio et Traitement Numérique
	d'antennes}

\chapter{Introduction aux antennes intelligentes}
\section{Description des applications}

\chapter{Notions fondamentales}
\section{Exercise Personnel 2.1 - Conditions de repliement spatial}

Ainsi, par analogie au théorème de Shannon établi pour l?échantillonnage dans le domaine temporel, il existe certaines contraintes sur la fréquence
d'échantillonnage spatial pour éliminer le repliement spatial (et non plus spectral).\\
Sachant que les fréquences spatiales normalisées sont non-ambiguës pour
$ -1/2 \leq u \leq +1/2 $ et que l'angle d'arrivée de l´onde est compris entre
$ -\pi/2 \leq \phi \leq +\pi/2 $.



\section{Exercise Personnel 2.2 - Diagrame de rayonnement}

On considére une antenne formée de M = 16 capteurs identiques linéarment espacés avec une\\
pondération uniforme c'est à dire $ \omega_m = 1/\sqrt{M}, m = 1,2,...,M  $\\
Avec le programme suivant obtenir le diagramme de rayonnement sur une échelle logarithmique.\\
Le paramètre sera l'espace inter-élément sur lambda en forme de ratio parce qu'on ne connais pas
à priori la magnitude de les deux.




\begin{lstlisting}[caption={Code puor initialisation des variables},label=code_initial]
%% VARIABLES GLOBALES

clc
clear all; % effacement de toutes les variables de l?espace travail
close all; % fermeture de tous les fichiers (éventuellement) ouverts
global NOMBRE_ANTENNES; % nombre total de capteurs de l?antenne
global BINARY_DATA_RATE; % débit de la source binaire transmise
global FACTEUR_SURECH; % facteur de sur-échantillonnage au récepteur
global ROLL_OFF_FACTOR; % facteur de retombée des filtres en cosinus sur-élévé
global SAMPLING_FREQ; % fréquence d?échantillonage du signal au récepteur
global BAUD_RATE; % rapidité de modulation des données transmises

%% INIT PARAMETRES

%=============================================================================
% 1- Exemple d?initialisation des ces paramètres
%=============================================================================
ROLL_OFF_FACTOR=0.3;
NOMBRE_ANTENNES=16;
FACTEUR_SURECH=2;
BANDWIDTH=200e3;
DUREE_SYMBOLE=1/BANDWIDTH;
BAUD_RATE=1/DUREE_SYMBOLE;
SAMPLING_FREQ=FACTEUR_SURECH*BAUD_RATE;
d_sur_lambda = [.125 .25 .5];
M = 16;
\end{lstlisting}
\newpage
\begin{lstlisting}[caption={Code puor le calcul du diagramme de rayonnement},label=code_C_carre]
nombre_points = 100;
phi = linspace(-pi/2,pi/2,nombre_points);
v = zeros(M,1);%

M_const = 1/M^0.5;
w = ones(16,1)*M_const;
for j = 1:3
	for i = 1:size(phi,2)
			for m = 1:size(v,1)
			v(m) = M_const*exp(-1i*2*pi*d_sur_lambda(j)*(m-1)*sin(phi(i)));  
			end
	C(i) = w'*v;
	end

C = abs(C).^2;
figure(); 
plot(phi,(C),'LineWidth',1);
grid on
figure();
TracePolar(phi,(C), -50);
end
\end{lstlisting}

D´après ce code on obtien 
%TODO change captions here
\begin{figure}[h]
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_1}
		\caption{Diagramme de rayonnement polaire en scale logaritmique}
		\label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_2}
		\caption{Diagramme de rayonnement en escale linéaire}
		\label{fig:sub2}
	\end{subfigure}
	\caption{Diagrammes correspondantes au parametrage de $ d/\lambda = 1/2 $}
	\label{fig:test}
\end{figure}

On voit dans que la valeur maximale de ces réponses est obtenue pour un angle égal à $ \phi_s = 0 $ parce que
l'amplitud de la signal bruité reçu pour chaque capteur est affecté pour un facteur exponencial qui depend de
l'angle d'incidence de l'onde reçu.
\begin{equation}
\tilde{x}_m=\tilde{x}_1(t)e^{-j\dfrac{2\pi}{\lambda}(D_m - D_1)sin(\phi)} 
\end{equation}

Ce qui est logique parce que c'est le cas ou la signal a une incidence directe et perpendicular ou capteurs.
%TODO change captions here
\begin{figure}[h]
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_3}
		\caption{A subfigure}
		\label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_4}
		\caption{A subfigure}
		\label{fig:sub2}
	\end{subfigure}
	\caption{A figure with two subfigures}
	\label{fig:test}
\end{figure}
%TODO change captions here
\begin{figure}[h]
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_5}
		\caption{A subfigure}
		\label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_6}
		\caption{A subfigure}
		\label{fig:sub2}
	\end{subfigure}
	\caption{A figure with two subfigures}
	\label{fig:test}
\end{figure}



\begin{verbatim}
 Une fois que vous avez analysé les conditions de repliement spatial, il faut que vous ayez dans vos programme Matlab une paramètre d_sur_lamda qui correspondra au rapport de la distance inter-capteur à lambda (longueur d'onde). En fait, le programme ne connait ni d, ni lambda, mais on va fixer le rapport entre ces deux quantité à des valeurs telles que 1/2, 1/4, ou 1/8. Une fois cela fait, il vous faut :
Théoriquement, en programmant la formule (2.8) du poly. Faire l'analyse sous Matlab du diagramme de l'antenne élémentaire comme indiqué sur le poly (exercice 2.2). Le tracer en linéaire (le module de C au carré exprimé en dB en fonction de Phi) puis en coordonnées polaire (avec le programme TracePolar.m en exécutant TracePolar(Phi, abs(C), -50)  où Phi est un vecteur d'angles, et où C est un vecteur stockant la réponse de l'antenne obtenue pour ces angles. 
Expérimentalement (exercice 2.3). Utiliser le programme GeneSignaux.m (cf. figure ci-dessous) pour obtenir les signaux sur les NOMBRE_ANTENNES antennes élémentaires au sein de la matrice  dénommée Sig 
            >> [MatriceIB,MatriceS,Sig,BinaireIn,PenteSCurve]=GeneSignaux(Phis,Phi1,Phi2,RSB,RSI1,RSI2)

 Je vous expliquerai ultérieurement comment on introduit des interférents dans la simulation. Pour l'instant, on introduit uniquement les signaux utiles issus de la source S ainsi que du bruit sur les signaux captés. Il faudra alors modifier les paramètres donnés page 24 selon :
 on choisit le niveau de bruit (relativement à celui du signal utile): 
donc on fixe le rapport signal-à-bruit RSB à une valeur voulue (entre 30 et 0 dB)
il n'y a pas d?interférent n°1 :
 donc le rapport signal-à-interférent n°1 RSI1 ---> infini (300 dB suffira)
on met n'importe quelle direction d'arrivée de l'interférent n°1 : Phi1 = -30 degrés *(pi/180)
il n'y a pas d?interférent n°2 : 
donc le rapport signal-à-interférent n°2 RSI2 ---> infini (300 dB suffira)
on met n'importe quelle direction d'arrivée de l'interférent n°2 : Phi2 = +60 degrés *(pi/180)
on choisit la direction de la source utile S : 
donc on fixe Phis à une valeur dans l'intervalle [-90°,+90°] * (pi/180)
   Pour cela , on fixera : 
le facteur de retombée du filtre d'émission/réception (1/2 Nyquist) : ROLL_OFF_FACTOR entre 0 et 1
le nombre d'antennes NOMBRE_ANTENNES
le facteur de sur-échantillonnage (cf. EII2) : FACTEUR_SURECH a une valeur paire 2, 4, 6, 8, 10, 16...
la bande passante du signal à BANDWIDTH=200e3 soit 200kHz (ceci est fixé arbitrairement!)
    et donc, on aura toujours (cf. EII2)

    DUREE_SYMBOLE=1/BANDWIDTH;
    BAUD_RATE=1/DUREE_SYMBOLE;
    SAMPLING_FREQ=FACTEUR_SURECH*BAUD_RATE;
\end{verbatim}

%TODO change captions here
\begin{figure}[h]
	\centering
	\includegraphics[width=.99\linewidth]{../block_genesignal}
	\caption{A subfigure}
	\label{fig:sub1}
\end{figure}

  


On obtien depuis notre code les diagramme de l'oeil qui nous permet de voir comment les signaux son..
%TODO change captions here
\begin{figure}[h]
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_7}
		\caption{A subfigure}
		\label{fig:sub1}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{../exo2_8}
		\caption{A subfigure}
		\label{fig:sub2}
	\end{subfigure}
	\caption{A figure with two subfigures}
	\label{fig:test}
\end{figure}


\section{Exercice Personnel 2.3 - Analyse du bruit}%TODO finish this calculations

\chapter{Première Optimisation}

\section{Exercice Personnel 3.11 - Solution Optimale}




\section{Exercice Personnel 3.2 - Analyse de la solution}








\end{document}
    
